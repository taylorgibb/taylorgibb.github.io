<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>Six Rules for Pull Requests That Actually Get Merged</title> <meta name="description" content="In professional software development, the code you write is only half of your job. The other half is getting that code merged." /> <meta property="og:image" content="https://taylorgibb.github.io/assets/facebook.png"/> <link rel="icon" href="https://taylorgibb.github.io/assets/favicon.png"> <link rel="apple-touch-icon" href="https://taylorgibb.github.io/assets/touch-icon.png"> <link rel="stylesheet" href="https://taylorgibb.github.io/assets/core.css"> <link rel="canonical" href="https://taylorgibb.github.io/blog/six-rules-for-pull-requests-that-actually-get-merged"> <link rel="alternate" type="application/atom+xml" title="Taylor Gibb" href="https://taylorgibb.github.io/feed.xml" /> <link href="https://fonts.googleapis.com/css?family=Roboto+Slab" rel="stylesheet"> <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script> </head> <body> <div class="logo-container"> <div class="logo-wrapper"> <img src="/assets/avatar.png" class="logo-avatar"> </div> </div> <div id="content"> <article> <div class="center"> <h1 class="title">Six Rules for Pull Requests That Actually Get Merged</h1> <time class="code">December 24, 2025</time> </div> <div class="divider"></div> <p>In professional software development, the code you write is only half of your job. The other half is getting that code <strong>merged.</strong></p> <p>We’ve all seen the “PR from Hell”: 1,200 lines across 40 files, a mix of logic, style changes, and unrelated fixes. These PRs are where productivity goes to die. They sit in the backlog for days because they are exhausting to review, and when they finally do get merged, they are magnets for bugs.</p> <p>I’ve developed six golden rules that transform how teams ship code. This isn’t just a checklist—it’s a strategy to reduce <strong>cognitive load</strong> for your team and increase your personal <strong>shipping velocity.</strong></p> <h2 id="1-do-exactly-one-thing">1. Do Exactly One Thing</h2> <p>The Single Responsibility Principle isn’t just for classes; it’s for Pull Requests. Every PR should solve one specific problem. When a PR does one thing, the reviewer’s mental model is stable. They know exactly what logic to look for. If you mix a bug fix with a new feature, you force the reviewer to context-switch mid-file.</p> <p>If you discover an unrelated bug while working on a feature, resist the urge to fix it there. Branch off, fix the bug in a 5-line PR, and keep your feature branch clean.</p> <h2 id="2-keep-it-small">2. Keep it Small</h2> <p>There is a famous tweet: <em>“Ask a programmer to review 10 lines of code, they’ll find 10 issues. Ask them to review 500 lines, they’ll say ‘looks good’.”</em></p> <p>Large PRs are impossible to audit thoroughly. By keeping your changes small (ideally under 200 lines), you ensure the reviewer actually reads every line rather than skimming. A PR should be reviewable in 15 minutes or less. If it’s bigger than that, you are essentially asking your teammates to spend their entire afternoon on your work.</p> <h2 id="3-separate-reformatting-from-logic">3. Separate Reformatting from Logic</h2> <p>Mixing “Prettier” updates or linting fixes with functional code changes is the fastest way to hide bugs. When a reviewer sees 50 lines of changed indentation, their brain starts to tune out. A malicious bug or a logic error can easily hide inside a wall of whitespace changes.</p> <p>Always follow the “Two-PR Policy”: first PR is purely mechanical (renaming, reformatting, linting), second PR is purely functional (the actual logic change).</p> <h2 id="4-prove-it-works">4. Prove It Works</h2> <p>It is not the reviewer’s job to find out if your code works; it is your job to prove it to them. Every minute a reviewer spends checking if your code actually runs is a minute of wasted team time.</p> <p>Every functional PR should include automated tests. If it’s a bug fix, include a regression test that fails without your changes and passes with them. This creates a permanent record that the problem is solved forever.</p> <h2 id="5-visual-evidence-for-frontend-changes">5. Visual Evidence for Frontend Changes</h2> <p>For any UI/UX change, a description is insufficient. “Changed the button padding” means different things to different people. Front-end code is visual, and reviewing it via text-based diffs is like trying to describe a painting over the phone.</p> <p>Attach a screenshot or a screen recording (Loom/GIF) to the PR. This allows the reviewer to verify the look and feel immediately. Often, a reviewer will spot a layout glitch in your screenshot that they would have missed in the code.</p> <h2 id="6-own-the-pr-lifecycle">6. Own the PR Lifecycle</h2> <p>The PR is a conversation, not a hand-off. Your responsibility doesn’t end when you hit “Create Pull Request.” Code rot is real, and the longer a PR sits, the more likely it is to encounter merge conflicts.</p> <p>Rebase regularly to ensure your branch is always compatible with <code class="language-plaintext highlighter-rouge">main</code>. Monitor CI and fix failures immediately—don’t wait for a reviewer to tell you your tests are failing. Once you have the approvals, be the one to click merge and verify the deployment.</p> <h2 id="the-future-of-code-review-stacked-diffs">The Future of Code Review: Stacked Diffs</h2> <p>The best developers aren’t just the ones who write the smartest code; they are the ones who make it easiest for the team to move forward. By following these six rules, you reduce friction, build trust, and ensure that your code actually makes it to production.</p> <p>The tooling around code reviews is evolving rapidly. <a href="https://x.com/jaredpalmer/status/1999525369725215106">Jared Palmer’s recent tweet</a> on the future of pull requests highlight an emerging paradigm: stacked diffs. Instead of waiting for one PR to be reviewed before starting the next, stacked diffs let you build a chain of dependent changes that can be reviewed in parallel.</p> <p>Tools like <a href="https://graphite.dev">Graphite</a> have been pioneering this workflow, making it possible to break large features into small, reviewable chunks without the coordination overhead. The race is heating up—Cursor recently acquired Graphite, and GitHub is adding native stacked diff support. It’s clear that the industry recognizes a fundamental truth: in the AI age, where we can generate code faster than ever, we need better review tooling to keep pace.</p> <p>The six rules above still apply, but the tooling is finally catching up to make them easier to follow. What is your “Golden Rule” for Pull Requests?</p> </article> </div> <div id="disqus_thread"></div> <script> var disqus_config = function () { this.page.url = "https://www.taylorgibb.com/blog/six-rules-for-pull-requests-that-actually-get-merged", this.page.identifier = "/blog/six-rules-for-pull-requests-that-actually-get-merged"; }; (function() { var d = document, s = d.createElement('script'); s.src = 'https://taylorgibb.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <script id="dsq-count-scr" src="//taylorgibb.disqus.com/count.js" async></script> <div class="footer"> <span class="block"><small>&lt;/&gt; Powered by <a href="https://jekyllrb.com/">Jekyll</a>, source code on <a href="https://github.com/taylorgibb/taylorgibb.github.io">Github</a></small></span> </div> </body> </html>
